{"ast":null,"code":"import { BinaryHeap } from \"./binaryHeap\";\nlet Grid, finishAt;\nlet allowedDirections = 4;\nlet parameterValues = []; //store values for nodes\n\nexport function aStar(grid, startNode, finishNode, allowedDir) {\n  let visitedNodesForAnimation = [];\n  Grid = grid; // startAt = startNode;\n\n  finishAt = finishNode;\n  allowedDirections = allowedDir;\n  var heap = getHeap();\n  parameterValues = initializeParameters(grid.length, grid[0].length); // var closestNode = startNode;\n\n  var startNodeParam = parameterValues[startNode.row][startNode.col];\n  startNodeParam.hScore = heuristicScore(startNode, finishNode);\n  startNodeParam.gScore = 0;\n  startNodeParam.fScore = startNodeParam.gScore + startNodeParam.hScore;\n  heap.push(startNode);\n\n  while (heap.size() > 0) {\n    //Get node with lowest f value\n    var currentNode = heap.pop();\n    visitedNodesForAnimation.push(currentNode); //End node has been found\n\n    if (currentNode === finishNode) {\n      return visitedNodesForAnimation;\n    } //Move currentNode from open to close list\n\n\n    var currNodeParam = parameterValues[currentNode.row][currentNode.col];\n    currNodeParam.isClose = true; //neighbours of current node\n\n    var neighbors = getNeighbors(currentNode);\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      var neighbor = neighbors[i];\n      var neighborParam = parameterValues[neighbor.row][neighbor.col];\n\n      if (neighborParam.isClose || neighbor.isWall) {\n        continue;\n      } //Get gScore. gScore = shortest distance from start\n\n\n      var gScore = currNodeParam.gScore + getCost(currentNode, neighbor);\n      var visited = neighbor.isVisited;\n\n      if (!visited || gScore < neighborParam.gScore) {\n        // Found an optimal path till this node\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        neighborParam.gScore = gScore;\n        neighborParam.hScore = heuristicScore(neighbor);\n        neighborParam.fScore = neighborParam.gScore + neighborParam.hScore;\n\n        if (!visited) {\n          //push to the heap\n          heap.push(neighbor);\n        } else {\n          heap.updateElement(neighbor);\n        }\n      }\n    }\n  }\n\n  return visitedNodesForAnimation;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return parameterValues[node.row][node.col].fScore;\n  });\n}\n\nfunction isValid(x, y) {\n  if (x >= 0 && x < Grid.length && y >= 0 && y < Grid[0].length) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction getNeighbors(node) {\n  var r = node.row;\n  var c = node.col;\n  var ret = [];\n  var x = [1, 0, -1, 0, 1, -1, -1, 1];\n  var y = [0, 1, 0, -1, 1, -1, 1, -1];\n\n  for (var i = 0; i < allowedDirections; ++i) {\n    if (isValid(r + x[i], c + y[i])) {\n      ret.push(Grid[r + x[i]][c + y[i]]);\n    }\n  }\n\n  return ret;\n}\n\nfunction getCost(src, dest) {\n  return dest.weight;\n}\n\nfunction heuristicScore(node, endNode) {\n  var d1 = Math.abs(node.row, finishAt.row);\n  var d2 = Math.abs(node.col, finishAt.col);\n  return d1 + d2;\n}\n\nfunction initializeParameters(GridRowSize, GridColSize) {\n  const parameters = [];\n\n  for (let r = 0; r < GridRowSize; ++r) {\n    const row = [];\n\n    for (let c = 0; c < GridColSize; ++c) {\n      row.push(createNode(r, c));\n    }\n\n    parameters.push(row);\n  }\n\n  return parameters;\n}\n\nconst createNode = (row, col) => {\n  return {\n    col,\n    row,\n    gScore: Infinity,\n    hScore: Infinity,\n    fScore: Infinity,\n    isOpen: false,\n    isClose: false\n  };\n};","map":{"version":3,"names":["BinaryHeap","Grid","finishAt","allowedDirections","parameterValues","aStar","grid","startNode","finishNode","allowedDir","visitedNodesForAnimation","heap","getHeap","initializeParameters","length","startNodeParam","row","col","hScore","heuristicScore","gScore","fScore","push","size","currentNode","pop","currNodeParam","isClose","neighbors","getNeighbors","i","neighbor","neighborParam","isWall","getCost","visited","isVisited","previousNode","updateElement","node","isValid","x","y","r","c","ret","src","dest","weight","endNode","d1","Math","abs","d2","GridRowSize","GridColSize","parameters","createNode","Infinity","isOpen"],"sources":["C:/Users/Sagar Yadav/OneDrive/Documents/Projects/PathFinding-Visualizer/src/algorithms/aStar.js"],"sourcesContent":["import { BinaryHeap } from \"./binaryHeap\";\r\n\r\nlet Grid, finishAt;\r\nlet allowedDirections = 4;\r\nlet parameterValues = []; //store values for nodes\r\n\r\nexport function aStar(grid, startNode, finishNode, allowedDir) {\r\n  let visitedNodesForAnimation = [];\r\n  Grid = grid;\r\n  // startAt = startNode;\r\n  finishAt = finishNode;\r\n  allowedDirections = allowedDir;\r\n  var heap = getHeap();\r\n  parameterValues = initializeParameters(grid.length, grid[0].length);\r\n  // var closestNode = startNode;\r\n  var startNodeParam = parameterValues[startNode.row][startNode.col];\r\n  startNodeParam.hScore = heuristicScore(startNode, finishNode);\r\n  startNodeParam.gScore = 0;\r\n  startNodeParam.fScore = startNodeParam.gScore + startNodeParam.hScore;\r\n\r\n  heap.push(startNode);\r\n\r\n  while (heap.size() > 0) {\r\n    //Get node with lowest f value\r\n\r\n    var currentNode = heap.pop();\r\n    visitedNodesForAnimation.push(currentNode);\r\n    //End node has been found\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesForAnimation;\r\n    }\r\n\r\n    //Move currentNode from open to close list\r\n    var currNodeParam = parameterValues[currentNode.row][currentNode.col];\r\n    currNodeParam.isClose = true;\r\n\r\n    //neighbours of current node\r\n    var neighbors = getNeighbors(currentNode);\r\n\r\n    for (var i = 0; i < neighbors.length; ++i) {\r\n      var neighbor = neighbors[i];\r\n      var neighborParam = parameterValues[neighbor.row][neighbor.col];\r\n      if (neighborParam.isClose || neighbor.isWall) {\r\n        continue;\r\n      }\r\n\r\n      //Get gScore. gScore = shortest distance from start\r\n      var gScore = currNodeParam.gScore + getCost(currentNode, neighbor);\r\n      var visited = neighbor.isVisited;\r\n\r\n      if (!visited || gScore < neighborParam.gScore) {\r\n        // Found an optimal path till this node\r\n        neighbor.isVisited = true;\r\n        neighbor.previousNode = currentNode;\r\n        neighborParam.gScore = gScore;\r\n        neighborParam.hScore = heuristicScore(neighbor);\r\n        neighborParam.fScore = neighborParam.gScore + neighborParam.hScore;\r\n\r\n        if (!visited) {\r\n          //push to the heap\r\n          heap.push(neighbor);\r\n        } else {\r\n          heap.updateElement(neighbor);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesForAnimation;\r\n}\r\n\r\nfunction getHeap() {\r\n  return new BinaryHeap(function (node) {\r\n    return parameterValues[node.row][node.col].fScore;\r\n  });\r\n}\r\n\r\nfunction isValid(x, y) {\r\n  if (x >= 0 && x < Grid.length && y >= 0 && y < Grid[0].length) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction getNeighbors(node) {\r\n  var r = node.row;\r\n  var c = node.col;\r\n  var ret = [];\r\n  var x = [1, 0, -1, 0, 1, -1, -1, 1];\r\n  var y = [0, 1, 0, -1, 1, -1, 1, -1];\r\n\r\n  for (var i = 0; i < allowedDirections; ++i) {\r\n    if (isValid(r + x[i], c + y[i])) {\r\n      ret.push(Grid[r + x[i]][c + y[i]]);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n}\r\n\r\nfunction getCost(src, dest) {\r\n  return dest.weight;\r\n}\r\n\r\nfunction heuristicScore(node, endNode) {\r\n  var d1 = Math.abs(node.row, finishAt.row);\r\n  var d2 = Math.abs(node.col, finishAt.col);\r\n  return d1 + d2;\r\n}\r\n\r\nfunction initializeParameters(GridRowSize, GridColSize) {\r\n  const parameters = [];\r\n  for (let r = 0; r < GridRowSize; ++r) {\r\n    const row = [];\r\n    for (let c = 0; c < GridColSize; ++c) {\r\n      row.push(createNode(r, c));\r\n    }\r\n    parameters.push(row);\r\n  }\r\n  return parameters;\r\n}\r\n\r\nconst createNode = (row, col) => {\r\n  return {\r\n    col,\r\n    row,\r\n    gScore: Infinity,\r\n    hScore: Infinity,\r\n    fScore: Infinity,\r\n    isOpen: false,\r\n    isClose: false,\r\n  };\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}