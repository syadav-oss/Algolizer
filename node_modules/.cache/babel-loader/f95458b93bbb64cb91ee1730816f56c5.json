{"ast":null,"code":"// Performs Depth First Search algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nlet allowedDirections = 4;\nexport function dfs(grid, startNode, finishNode, allowedDir) {\n  allowedDirections = allowedDir;\n  const visitedNodesForAnimation = [];\n  const nodesStack = [];\n  nodesStack.push(startNode); // getAllFromGrid(grid);\n\n  const xdir = [1, 0, -1, 0, 1, -1, -1, 1];\n  const ydir = [0, 1, 0, -1, 1, -1, 1, -1];\n\n  while (nodesStack.length) {\n    const currentNode = nodesStack.pop(); // If finish node then we reach the destination\n\n    if (currentNode === finishNode) return visitedNodesForAnimation;\n\n    if (!currentNode.isWall && !currentNode.isVisited) {\n      currentNode.isVisited = true;\n      visitedNodesForAnimation.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      let nextNode;\n      let nextrow, nextcol;\n\n      for (let i = 0; i < allowedDirections; ++i) {\n        nextrow = row + xdir[i];\n        nextcol = col + ydir[i];\n\n        if (nextrow >= 0 && nextrow < grid.length && nextcol >= 0 && nextcol < grid[0].length) {\n          nextNode = grid[nextrow][nextcol];\n\n          if (!nextNode.isVisited && !nextNode.isWall) {\n            nextNode.previousNode = currentNode;\n            nodesStack.push(nextNode);\n          }\n        }\n      }\n    }\n  }\n\n  return visitedNodesForAnimation;\n}","map":{"version":3,"names":["allowedDirections","dfs","grid","startNode","finishNode","allowedDir","visitedNodesForAnimation","nodesStack","push","xdir","ydir","length","currentNode","pop","isWall","isVisited","col","row","nextNode","nextrow","nextcol","i","previousNode"],"sources":["C:/Users/Sagar Yadav/OneDrive/Documents/Projects/PathFinding-Visualizer/src/algorithms/dfs.js"],"sourcesContent":["// Performs Depth First Search algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nlet allowedDirections = 4;\r\n\r\nexport function dfs(grid, startNode, finishNode, allowedDir) {\r\n  allowedDirections = allowedDir;\r\n  const visitedNodesForAnimation = [];\r\n  \r\n  const nodesStack = [];\r\n  nodesStack.push(startNode);\r\n  // getAllFromGrid(grid);\r\n  const xdir = [1, 0, -1, 0, 1, -1, -1, 1];\r\n  const ydir = [0, 1, 0, -1, 1, -1, 1, -1];\r\n\r\n  while (nodesStack.length) {\r\n    const currentNode = nodesStack.pop();\r\n\r\n    // If finish node then we reach the destination\r\n    if (currentNode === finishNode) return visitedNodesForAnimation;\r\n\r\n    if (!currentNode.isWall && !currentNode.isVisited) {\r\n      currentNode.isVisited = true;\r\n      visitedNodesForAnimation.push(currentNode);\r\n\r\n      const { col, row } = currentNode;\r\n      let nextNode;\r\n      let nextrow, nextcol;\r\n\r\n      for (let i = 0; i < allowedDirections; ++i) {\r\n        nextrow = row + xdir[i];\r\n        nextcol = col + ydir[i];\r\n\r\n        if (\r\n          nextrow >= 0 &&\r\n          nextrow < grid.length &&\r\n          nextcol >= 0 &&\r\n          nextcol < grid[0].length\r\n        ) {\r\n          nextNode = grid[nextrow][nextcol];\r\n          if (!nextNode.isVisited && !nextNode.isWall) {\r\n            nextNode.previousNode = currentNode;\r\n            nodesStack.push(nextNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesForAnimation;\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,iBAAiB,GAAG,CAAxB;AAEA,OAAO,SAASC,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0CC,UAA1C,EAAsD;EAC3DL,iBAAiB,GAAGK,UAApB;EACA,MAAMC,wBAAwB,GAAG,EAAjC;EAEA,MAAMC,UAAU,GAAG,EAAnB;EACAA,UAAU,CAACC,IAAX,CAAgBL,SAAhB,EAL2D,CAM3D;;EACA,MAAMM,IAAI,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAC,CAAlB,EAAqB,CAAC,CAAtB,EAAyB,CAAzB,CAAb;EACA,MAAMC,IAAI,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAC,CAAX,EAAc,CAAd,EAAiB,CAAC,CAAlB,EAAqB,CAArB,EAAwB,CAAC,CAAzB,CAAb;;EAEA,OAAOH,UAAU,CAACI,MAAlB,EAA0B;IACxB,MAAMC,WAAW,GAAGL,UAAU,CAACM,GAAX,EAApB,CADwB,CAGxB;;IACA,IAAID,WAAW,KAAKR,UAApB,EAAgC,OAAOE,wBAAP;;IAEhC,IAAI,CAACM,WAAW,CAACE,MAAb,IAAuB,CAACF,WAAW,CAACG,SAAxC,EAAmD;MACjDH,WAAW,CAACG,SAAZ,GAAwB,IAAxB;MACAT,wBAAwB,CAACE,IAAzB,CAA8BI,WAA9B;MAEA,MAAM;QAAEI,GAAF;QAAOC;MAAP,IAAeL,WAArB;MACA,IAAIM,QAAJ;MACA,IAAIC,OAAJ,EAAaC,OAAb;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrB,iBAApB,EAAuC,EAAEqB,CAAzC,EAA4C;QAC1CF,OAAO,GAAGF,GAAG,GAAGR,IAAI,CAACY,CAAD,CAApB;QACAD,OAAO,GAAGJ,GAAG,GAAGN,IAAI,CAACW,CAAD,CAApB;;QAEA,IACEF,OAAO,IAAI,CAAX,IACAA,OAAO,GAAGjB,IAAI,CAACS,MADf,IAEAS,OAAO,IAAI,CAFX,IAGAA,OAAO,GAAGlB,IAAI,CAAC,CAAD,CAAJ,CAAQS,MAJpB,EAKE;UACAO,QAAQ,GAAGhB,IAAI,CAACiB,OAAD,CAAJ,CAAcC,OAAd,CAAX;;UACA,IAAI,CAACF,QAAQ,CAACH,SAAV,IAAuB,CAACG,QAAQ,CAACJ,MAArC,EAA6C;YAC3CI,QAAQ,CAACI,YAAT,GAAwBV,WAAxB;YACAL,UAAU,CAACC,IAAX,CAAgBU,QAAhB;UACD;QACF;MACF;IACF;EACF;;EACD,OAAOZ,wBAAP;AACD"},"metadata":{},"sourceType":"module"}