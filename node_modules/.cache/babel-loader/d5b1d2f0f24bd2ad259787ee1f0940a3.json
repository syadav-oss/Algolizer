{"ast":null,"code":"// Performs Depth First Search algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nlet allowedDirections = 4;\nexport function bfs(grid, startNode, finishNode, allowedDir) {\n  allowedDirections = allowedDir;\n  const visitedNodesForAnimation = [];\n  const nodesQueue = [];\n  nodesQueue.push(startNode); // getAllFromGrid(grid);\n\n  const xdir = [1, 0, -1, 0, 1, -1, -1, 1];\n  const ydir = [0, 1, 0, -1, 1, -1, 1, -1];\n  startNode.distance = 0;\n  startNode.isVisited = true;\n\n  while (nodesQueue.length) {\n    const currentNode = nodesQueue.shift(); // If finish node then we reach the destination\n\n    if (currentNode === finishNode) return visitedNodesForAnimation;\n\n    if (!currentNode.isWall) {\n      visitedNodesForAnimation.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      let nextNode;\n      let nextrow, nextcol;\n\n      for (let i = 0; i < allowedDirections; ++i) {\n        nextrow = row + xdir[i];\n        nextcol = col + ydir[i];\n\n        if (nextrow >= 0 && nextrow < grid.length && nextcol >= 0 && nextcol < grid[0].length && !grid[nextrow][nextcol].isVisited && !grid[nextrow][nextcol].isWall) {\n          nextNode = grid[nextrow][nextcol];\n          nextNode.isVisited = true;\n          nextNode.distance = currentNode.distance + 1;\n          nextNode.previousNode = currentNode;\n          nodesQueue.push(nextNode);\n        }\n      }\n    }\n  }\n\n  return visitedNodesForAnimation;\n}","map":{"version":3,"names":["allowedDirections","bfs","grid","startNode","finishNode","allowedDir","visitedNodesForAnimation","nodesQueue","push","xdir","ydir","distance","isVisited","length","currentNode","shift","isWall","col","row","nextNode","nextrow","nextcol","i","previousNode"],"sources":["C:/Users/Sagar Yadav/OneDrive/Documents/Projects/PathFinding-Visualizer/src/algorithms/bfs.js"],"sourcesContent":["// Performs Depth First Search algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nlet allowedDirections = 4;\r\n\r\nexport function bfs(grid, startNode, finishNode, allowedDir) {\r\n    allowedDirections = allowedDir;\r\n    const visitedNodesForAnimation = [];\r\n  \r\n    const nodesQueue = [];\r\n    nodesQueue.push(startNode);\r\n    // getAllFromGrid(grid);\r\n    const xdir = [1, 0, -1, 0, 1, -1, -1, 1];\r\n    const ydir = [0, 1, 0, -1, 1, -1, 1, -1];\r\n    startNode.distance = 0;\r\n    startNode.isVisited = true;\r\n  \r\n    while (nodesQueue.length) {\r\n      const currentNode = nodesQueue.shift();\r\n  \r\n      // If finish node then we reach the destination\r\n      if (currentNode === finishNode) return visitedNodesForAnimation;\r\n  \r\n      if (!currentNode.isWall) {\r\n        visitedNodesForAnimation.push(currentNode);\r\n  \r\n        const { col, row } = currentNode;\r\n        let nextNode;\r\n        let nextrow, nextcol;\r\n  \r\n        for (let i = 0; i < allowedDirections; ++i) {\r\n          nextrow = row + xdir[i];\r\n          nextcol = col + ydir[i];\r\n  \r\n          if (\r\n            nextrow >= 0 &&\r\n            nextrow < grid.length &&\r\n            nextcol >= 0 &&\r\n            nextcol < grid[0].length &&\r\n            !grid[nextrow][nextcol].isVisited &&\r\n            !grid[nextrow][nextcol].isWall\r\n          ) {\r\n            nextNode = grid[nextrow][nextcol];\r\n            nextNode.isVisited = true;\r\n            nextNode.distance = currentNode.distance + 1;\r\n            nextNode.previousNode = currentNode;\r\n            nodesQueue.push(nextNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return visitedNodesForAnimation;\r\n  }\r\n  "],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAIA,iBAAiB,GAAG,CAAxB;AAEA,OAAO,SAASC,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0CC,UAA1C,EAAsD;EACzDL,iBAAiB,GAAGK,UAApB;EACA,MAAMC,wBAAwB,GAAG,EAAjC;EAEA,MAAMC,UAAU,GAAG,EAAnB;EACAA,UAAU,CAACC,IAAX,CAAgBL,SAAhB,EALyD,CAMzD;;EACA,MAAMM,IAAI,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAC,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAC,CAAlB,EAAqB,CAAC,CAAtB,EAAyB,CAAzB,CAAb;EACA,MAAMC,IAAI,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAC,CAAX,EAAc,CAAd,EAAiB,CAAC,CAAlB,EAAqB,CAArB,EAAwB,CAAC,CAAzB,CAAb;EACAP,SAAS,CAACQ,QAAV,GAAqB,CAArB;EACAR,SAAS,CAACS,SAAV,GAAsB,IAAtB;;EAEA,OAAOL,UAAU,CAACM,MAAlB,EAA0B;IACxB,MAAMC,WAAW,GAAGP,UAAU,CAACQ,KAAX,EAApB,CADwB,CAGxB;;IACA,IAAID,WAAW,KAAKV,UAApB,EAAgC,OAAOE,wBAAP;;IAEhC,IAAI,CAACQ,WAAW,CAACE,MAAjB,EAAyB;MACvBV,wBAAwB,CAACE,IAAzB,CAA8BM,WAA9B;MAEA,MAAM;QAAEG,GAAF;QAAOC;MAAP,IAAeJ,WAArB;MACA,IAAIK,QAAJ;MACA,IAAIC,OAAJ,EAAaC,OAAb;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGtB,iBAApB,EAAuC,EAAEsB,CAAzC,EAA4C;QAC1CF,OAAO,GAAGF,GAAG,GAAGT,IAAI,CAACa,CAAD,CAApB;QACAD,OAAO,GAAGJ,GAAG,GAAGP,IAAI,CAACY,CAAD,CAApB;;QAEA,IACEF,OAAO,IAAI,CAAX,IACAA,OAAO,GAAGlB,IAAI,CAACW,MADf,IAEAQ,OAAO,IAAI,CAFX,IAGAA,OAAO,GAAGnB,IAAI,CAAC,CAAD,CAAJ,CAAQW,MAHlB,IAIA,CAACX,IAAI,CAACkB,OAAD,CAAJ,CAAcC,OAAd,EAAuBT,SAJxB,IAKA,CAACV,IAAI,CAACkB,OAAD,CAAJ,CAAcC,OAAd,EAAuBL,MAN1B,EAOE;UACAG,QAAQ,GAAGjB,IAAI,CAACkB,OAAD,CAAJ,CAAcC,OAAd,CAAX;UACAF,QAAQ,CAACP,SAAT,GAAqB,IAArB;UACAO,QAAQ,CAACR,QAAT,GAAoBG,WAAW,CAACH,QAAZ,GAAuB,CAA3C;UACAQ,QAAQ,CAACI,YAAT,GAAwBT,WAAxB;UACAP,UAAU,CAACC,IAAX,CAAgBW,QAAhB;QACD;MACF;IACF;EACF;;EACD,OAAOb,wBAAP;AACD"},"metadata":{},"sourceType":"module"}